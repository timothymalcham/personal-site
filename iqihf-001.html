<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Timothy Malcham</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Merriweather:400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="style/style.css">
</head>
<body>
<div class="container">
  <h1 class="title">Interview Questions I've Failed, 001 (JavaScript Scope)</h1>

  <p>
    I have a history of failing technical interviews. During the interview, whether
    it's over the phone or in person, I get sweaty palms, my mind goes blank, and
    I start thinking about how I might go about switching careers to something
    that doesn't involve memorizing a thousand different things. But after those
    interviews, I usually walked out knowing something new. Sometimes interviewers
    are entirely unhelpful when it comes to giving feedback and helping you out
    when you simply don't know something, but at the very least I ended up with a stronger
    desire to become a better programmer, and therefore, a better engineer.
  <p>

  <p>
    I'm writing a series of posts on questions I've been asked during interviews
    that I did not answer correctly, or I may have stumbled through the question
    without having a full understanding of the answer. I'll be reviewing the
    question asked and provide the correct answer and why it is correct. My hope
    is to have a deeper understanding of the concept the interview question was
    based around, and hopefully help someone else out in the process.
  </p>
  <p>
    This first question isn't one I really 'failed', per se. I got through about
    75% of the question and tripped over a few parts of it. The question was all
    about scope in JavaScript, which is super important to have a solid grasp of
    if you write JavaScript regurarly, so I wanted to go back and make sure I really
    understood each part of the question well.
  </p>
  <p>
    If you're curious, this question was asked during a phone screen, by an
    engineer at a very large tech company. Sometimes the type of questions asked
    differs depending on the size and nature of the hiring company, so I'll make
    note of the context.
  </p>

  <p class="title">The Question:</p>

  <p>
    Given this block of code, when it is run, what will each <code>console.log</code>
    statement print out?
  </p>

  <pre><code data-language="javascript">(function() {

  var x = 1;

  function test() {
    console.log('First log statement: ', x);
    x = 2;
  }

  (function(x) {
    x = 3;
    console.log('Second log statement:', x);
    test();
    console.log('Third log statement:', x);
  }(x));

  console.log('Fourth log statement:', x);

  (function() {
    console.log('Fifth log statement:', x);
    var x = 4;
    console.log('Sixth log statement:', x);
  }());

  console.log('Seventh log statement:', x);

}());</code></pre>

  <p>
    If you run this code in your browser's developer tools console, you will get
    this output:
  </p>

  <code><pre>
  Second log statement: 3
  First log statement: 1
  Third log statement: 3
  Fourth log statement: 2
  Fifth log statement: undefined
  Sixth log statement: 4
  Seventh log statement: 2</pre></code>

  <p>
    Let’s go through this line by line and learn why we get this output.
  </p>

  <p>
    One note before we get started talking about scope. You might notice that
    some of the above functions look a bit strange, like this:
  </p>

  <pre><code data-language="javascript">(function(x) {
  // function code goes here…
}(x));</code></pre>

  <p>
    These are Immediately-Invoked Function Expressions or IIFEs. They're a bit
    self explanatory, they are functions that run (get invoked) immediately as
    soon as the parser reaches it when your program is getting executed. This
    unlike a function that gets declared and then called later on. Both happens at
    the same time with IIFEs. But like other ways of creating a function, IIFEs
    still create a new execution context, which defines a scope for variables
    and other functions to live in.
  </p>

  <p class="title">Line 1</p>

  <pre><code data-language="javascript">(function() {</code></pre>

  <p>
    Let’s get started on the actual question though. On line 1, we have an IIFE
    that encapsulates our entire program, creating an execution context for
    everything else to live inside of. Simple enough, let's move on.
  </p>

  <p class="title">Line 3</p>

  <pre><code data-language="javascript">var x = 1;</code></pre>

  <p>
    A variable is declared, and a value of <code>1</code> is assigned to it.
    Nothing super exciting yet, but the real action starts soon.
  </p>

  <p class="title">Line 5</p>

  <pre><code data-language="javascript">function test() {</code></pre>

  <p>
    A function is declared within the IIFE. We call it test and pass no arguments
    to it. We have another JS concept to introduce, which happens to be a very
    important part of the language – <i>closures</i>.
  </p>

  <p>
    A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">
    closure</a> is a function that gets declared within the scope (execution context)
    of another function. A closure gets access to variables that were declared
    within the scope of its parent. The fact that inner functions get access to
    their parent's variables is a powerful part of JS, so I'd recommend learning
    <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.gl5jqubrk">
    more about it.</a>
  </p>

  <p class="title">Line 6</p>

  <pre><code data-language="javascript">console.log('First log statement: ', x);</code></pre>

  <p>
    Our first <code>console.log</code> statement! One important thing to note here.
    Scroll back up and look at the output we got when the entire program was ran.
    The "First log statement" didn't actually get printed out first, it got
    printed out after the second one! This is because the first log statement is
    inside of a function declaration that hasn't been invoked / called yet
    (spoiler alert: this won't happen until line 13). We'll come back to this
    line (and line 7) later, since it won't actually run until later.
  </p>

  <p class="title">Line 10</p>

  <pre><code data-language="javascript">(function(x) {</code></pre>

  <p>
    Another IIFE, which like <code>test</code> above, is a function, and because
    it's nested within another function (the outer IIFE), it's a closure. It's
    also getting passed an argument, <code>x</code>. You can think of the IIFE's
    <code>x</code> as its own special <code>x</code>. In this case, it's not the
    same variable as the one defined in the outer scope. But the argument does get
    assigned the value of the outer variable <code>x</code>, as seen on line 15:
  </p>

  <pre><code data-language="javascript">}(x));</code></pre>

  <p>
    So what will the argument <code>x</code> be? Well, we know that <code>var x</code>
    was assigned the value 1, so we know that the argument will have the value
    of 1 as well.
  </p>

  <p class="title">Line 11</p>

  <pre><code data-language="javascript">x = 3;</code></pre>

  <p>
    On line 11 <code>x</code> is being assigned the value 3. Now, <code>x</code>
    in this case is the argument <code>x</code>, not the outer variable <code>x</code>.
    Keep that in mind for later. The argument's value is changed and now we arrive at
    the second log statement.
  </p>

  <p class="title">Line 12</p>

  <pre><code data-language="javascript">console.log('Second log statement:', x);</code></pre>

  <p>
    We log the value of x at the current point in the program, and we get <code>3</code>.
    This is pretty simple to understand, based on line 11.
  </p>

  <p class="title">Line 13</p>

  <pre><code data-language="javascript">test();</code></pre>

  <p>
    Now we finally call the function <code>test</code> that we declared earlier
    on lines 5-8. So now we travel back up to line 6 and execute the code
    within the function's body:
  </p>

  <pre><code data-language="javascript">console.log('First log statement: ', x);
x = 2;</code></pre>

  <p>
    The log statment on line 6 fires, printing 1. <code>test</code> is being invoked
    within the inner IIFE, but it was declared in the outer one. Because <code>test</code>
    is a closure and has access to the variables within its parent's scope, it
    grabs the variable <code>x</code> and prints it out, giving us 1. Then on
    line 7, <code>test</code> is going to assign a new value to that outer
    variable, 2. At this point, <code>test</code> is done executing.
  </p>

  <p class="title">Line 14</p>

  <pre><code data-language="javascript">console.log('Third log statement:', x);</code></pre>

  <p>
    We return to the first nested IIFE, and the third log statement fires, giving
    us 3 again. Remember, this nested IIFE isn't logging the outer variable
    <code>x</code>, it's logging out its argument, <code>x</code>, which has not
    been altered in any way. We've already covered line 15, so we're all finished
    with this nested IIFE.
  </p>

  <p class="title">Line 17</p>

  <pre><code data-language="javascript">console.log('Fourth log statement:', x);</code></pre>

  <p>
    We're back in the immediate scope of the parent IIFE that is first declared on
    line 1. The fourth log statement fires and gives us 2. Remember, the function
    <code>test</code> fired just a few lines back, and within that function, the
    outer variable <code>x</code> was given the value of 2, which is what we see
    here.
  </p>



<!--   <h2 class="title">Blog</h2>
  <i>Coming Soon …</i> -->

  <script src="js/rainbow.min.js"></script>

</div>
</body>
</html>