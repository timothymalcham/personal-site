<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Timothy Malcham</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Merriweather:400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="../../style/style.css">
</head>
<body>
<div class="container">
  <h1 class="title">Interview Questions I've Failed, 001: JavaScript Scope</h1>

  <p>
    I have a history of failing technical interviews. Way too often during an
    interview I start to get anxious, my mind goes blank, and I start thinking about
    how I might go about switching careers to something that doesn't involve
    memorizing a thousand different things.
    But after those interviews, I usually walked out knowing something new.
    Sometimes interviewers are entirely unhelpful when it comes to giving feedback
    and helping you out when you simply don't know something, but at the very
    least I end up with a stronger desire to become a better programmer, and
    therefore, a better engineer.
  <p>

  <p>
    I'm writing a series of posts on questions I've been asked during interviews
    that I did not answer correctly, or stumbled through without having a full
    understanding of the answer. I'll be reviewing the question asked, provide
    the correct answer, and explain why it is correct. My hope is to have a deeper
    understanding of the concept the interview question was based around, and
    hopefully help someone else out in the process.
  </p>
  <p>
    This first question isn't one I really 'failed', per se. I got through about
    75% of the question and tripped over a few parts of it. The question was all
    about scope in JavaScript, which is super important to have a solid grasp of
    if you write JavaScript regularly, so I wanted to go back and make sure I really
    understood each part of the question well.
  </p>
  <p>
    If you're curious, this question was asked during a phone screen, by an
    engineer at a very large tech company. Sometimes the type of questions asked
    differs depending on the size and nature of the hiring company, so I'll make
    note of the context.
  </p>

  <p>
    <i>
      If you notice any technical or grammatical errors, please feel free to
      open an issue on <a href="https://github.com/timothymalcham/personal-site/issues">
      github</a>. That would be super helpful. Thanks!
    </i>
  </p>

  <p class="title">The Question:</p>

  <p>
    Given this block of code, when it is run, what will each <code>console.log</code>
    statement print out?
  </p>

  <pre><code data-language="javascript">(function() {

  var x = 1;

  function test() {
    console.log('First log statement: ', x);
    x = 2;
  }

  (function(x) {
    x = 3;
    console.log('Second log statement:', x);
    test();
    console.log('Third log statement:', x);
  }(x));

  console.log('Fourth log statement:', x);

  (function() {
    console.log('Fifth log statement:', x);
    var x = 4;
    console.log('Sixth log statement:', x);
  }());

  console.log('Seventh log statement:', x);

}());</code></pre>

  <p>
    If you run this code in your browser's developer tools console, you will get
    this output:
  </p>

  <code><pre>
  Second log statement: 3
  First log statement: 1
  Third log statement: 3
  Fourth log statement: 2
  Fifth log statement: undefined
  Sixth log statement: 4
  Seventh log statement: 2</pre></code>

  <p>
    Let’s go through this line by line and learn why we get this output.
  </p>

  <p>
    One note before we get started talking about scope. You might notice that
    some of the above functions look a bit strange, like this:
  </p>

  <pre><code data-language="javascript">(function(x) {
  // function code goes here…
}(x));</code></pre>

  <p>
    These are Immediately-Invoked Function Expressions or IIFEs. They're a bit
    self explanatory, they are functions that run (get invoked) immediately as
    soon as the parser reaches it when your program is getting executed. This
    unlike a function that gets declared and then called later on. Both happens at
    the same time with IIFEs. But like other ways of creating a function, IIFEs
    still create a new execution context, which defines a scope for variables
    and other functions to live in.
  </p>

  <p class="title">Line 1</p>

  <pre><code data-language="javascript">(function() {</code></pre>

  <p>
    Let’s get started on the actual question though. On line 1, we have an IIFE
    that encapsulates our entire program, creating an execution context for
    everything else to live inside of. Simple enough, let's move on.
  </p>

  <p class="title">Line 3</p>

  <pre><code data-language="javascript">var x = 1;</code></pre>

  <p>
    A variable is declared, and a value of <code>1</code> is assigned to it.
    Nothing super exciting yet, but the real action starts soon.
  </p>

  <p class="title">Line 5</p>

  <pre><code data-language="javascript">function test() {</code></pre>

  <p>
    A function is declared within the IIFE. We call it test and pass no arguments
    to it. We have another JS concept to introduce, which happens to be a very
    important part of the language – <i>closures</i>.
  </p>

  <p>
    A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">
    closure</a> is a function that gets declared within the scope (execution context)
    of another function. A closure gets access to variables that were declared
    within the scope of its parent. The fact that inner functions get access to
    their parent's variables is a powerful part of JS, so I'd recommend learning
    <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.gl5jqubrk">
    more about it.</a>
  </p>

  <p class="title">Line 6</p>

  <pre><code data-language="javascript">console.log('First log statement: ', x);</code></pre>

  <p>
    Our first <code>console.log</code> statement! One important thing to note here.
    Scroll back up and look at the output we got when the entire program was ran.
    The "First log statement" didn't actually get printed out first, it got
    printed out after the second one! This is because the first log statement is
    inside of a function declaration that hasn't been invoked / called yet
    (spoiler alert: this won't happen until line 13). We'll come back to this
    line (and line 7) later, since it won't actually run until later.
  </p>

  <p class="title">Line 10</p>

  <pre><code data-language="javascript">(function(x) {</code></pre>

  <p>
    Another IIFE, which like <code>test</code> above, is a function, and because
    it's nested within another function (the outer IIFE), it's a closure. It's
    also getting passed an argument, <code>x</code>. You can think of the IIFE's
    <code>x</code> as its own special <code>x</code>. In this case, it's not the
    same variable as the one defined in the outer scope. But the argument does get
    assigned the value of the outer variable <code>x</code>, as seen on line 15:
  </p>

  <pre><code data-language="javascript">}(x));</code></pre>

  <p>
    So what will the argument <code>x</code> be? Well, we know that <code>var x</code>
    was assigned the value 1, so we know that the argument will have the value
    of 1 as well.
  </p>

  <p class="title">Line 11</p>

  <pre><code data-language="javascript">x = 3;</code></pre>

  <p>
    On line 11 <code>x</code> is being assigned the value 3. Now, <code>x</code>
    in this case is the argument <code>x</code>, not the outer variable <code>x</code>.
    Keep that in mind for later. The argument's value is changed and now we arrive at
    the second log statement.
  </p>

  <p class="title">Line 12</p>

  <pre><code data-language="javascript">console.log('Second log statement:', x);</code></pre>

  <p>
    We log the value of x at the current point in the program, and we get <code>3</code>.
    This is pretty simple to understand, based on line 11.
  </p>

  <p class="title">Line 13</p>

  <pre><code data-language="javascript">test();</code></pre>

  <p>
    Now we finally call the function <code>test</code> that we declared earlier
    on lines 5-8. So now we travel back up to line 6 and execute the code
    within the function's body:
  </p>

  <pre><code data-language="javascript">console.log('First log statement: ', x);
x = 2;</code></pre>

  <p>
    The log statement on line 6 fires, printing 1. <code>test</code> is being invoked
    within the inner IIFE, but it was declared in the outer one. Because <code>test</code>
    is a closure and has access to the variables within its parent's scope, it
    grabs the variable <code>x</code> and prints it out, giving us 1. Then on
    line 7, <code>test</code> is going to assign a new value to that outer
    variable, 2. At this point, <code>test</code> is done executing.
  </p>

  <p class="title">Line 14</p>

  <pre><code data-language="javascript">console.log('Third log statement:', x);</code></pre>

  <p>
    We return to the first nested IIFE, and the third log statement fires, giving
    us 3 again. Remember, this nested IIFE isn't logging the outer variable
    <code>x</code>, it's logging out its argument, <code>x</code>, which has not
    been altered in any way. We've already covered line 15, so we're all finished
    with this nested IIFE.
  </p>

  <p class="title">Line 17</p>

  <pre><code data-language="javascript">console.log('Fourth log statement:', x);</code></pre>

  <p>
    We're back in the immediate scope of the parent IIFE that is first declared on
    line 1. The fourth log statement fires and gives us 2. Remember, the function
    <code>test</code> fired just a few lines back, and within that function, the
    outer variable <code>x</code> was given the value of 2, which is what we see
    here.
  </p>

  <p class="title">Line 19</p>

  <pre><code data-language="javascript">(function() {</code></pre>

  <p>
    Another nested IIFE. Note that this one doesn't have any arguments.
  </p>

  <p class="title">Line 20</p>

  <pre><code data-language="javascript">console.log('Fifth log statement:', x);</code></pre>

  <p>
    The fifth log statement fires, and it tells us that at this point in the program,
    <code>x</code> is <code>undefined</code>. Wait. Isn't this a closure? Doesn't
    this IIFE have access to the variables in its parent scope? Shouldn't this log
    statement log out the same thing as the fourth log statement – 2? Let's go
    down to line 21 to find out why.
  </p>

  <p class="title">Line 21</p>

  <pre><code data-language="javascript">var x = 4;</code></pre>

  <p>
    In the log statement on line 20, we get <code>undefined</code> because this
    IIFE does have its own <code>var x</code>, which is declared on this line.
    What we witness on line 20, is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting">
    hoisting</a>. Whenever you do a declaration (i.e. <code>var</code> or <code>
    function name() {}</code>), the variable or function gets 'hoisted' to the
    top of the most immediate scope, which in this case is the top of this nested
    IIFE. The important thing to know is that the assignment doesn't get hoisted,
    only the declared variable itself. This is essentially how the parser sees
    this block of code:
  </p>

  <pre><code data-language="javascript">(function() {
  var x;
  console.log('Fifth log statement:', x); // x = undefined
  x = 4;
  console.log('Sixth log statement:', x); // x = 4
}());</code></pre>

  <p>
    The variable gets declared at the top of the immediate scope, but gets assigned
    on the line where you do the assignment (<code>= 4</code>).
  </p>

  <p class="title">Line 22</p>

  <pre><code data-language="javascript">console.log('Sixth log statement:', x);</code></pre>

  <p>
    The sixth log statement prints out 4. This one is straightforward, nothing
    that special going on after all that hoisting and assignment.
  </p>

  <p class="title">Line 25</p>

  <pre><code data-language="javascript">console.log('Seventh log statement:', x);</code></pre>

  <p>
    Let's jump down to the last noteworthy line of our program. The seventh and final
    log statement gives us 2. This is because this log statement lives in the
    parent IIFE function scope, where <code>x = 2</code>. The last nested IIFE
    (the one with the hoisting) declared and worked on a new variable that just
    also happened to be called x, but yet is unrelated to the the <code>var x</code>
    that was declared on line 3. All the variables in this program are given the
    name x purely to make you think hard about each different scope this program
    has. In a real piece of code, in almost all cases, you wouldn't give a variable
    the name x and you wouldn't do it multiple times in the same function.
  </p>

  <p>
    We've reached the end of the program, and have seen a few idiosyncrasies
    of JavaScript scope. Knowing these details and understanding the concepts behind
    them is essential to working with JavaScript in a sane and effective manner.
  </p>

  <p class="title">Bonus: ES6 / ES2015</p>

  <p>
    The way scope in JavaScript behaves changes a bit when you introduce new
    language features like <code>let</code>. <code>let</code> declares <i>block scope</i>
    variables, as opposed to <i>function scope</i> variables, like <code>var</code>
    does. If you're curious, here's the original question rewritten ES6-style.
    You still get same output as the ES5 code.
  </p>

  <pre><code data-language="javascript">(() => {

  let x = 1;

  function test() {
    console.log('First log statement:', x);
    x = 2;
  }

  ((x) => {
    x = 3;
    console.log('Second log statement:', x);
    test();
    console.log('Third log statement:', x);
  })(x);

  console.log('Fourth log statement:', x);

  (() => {
    console.log('Fifth log statement:', x);
    let x = 4;
    console.log('Sixth log statement:', x);
  })();

  console.log('Seventh log statement:', x);

})();</code></pre>

  <p>
    Note that you can also change up how the code works by using blocks instead
    of functions / IIFEs. This does change the output, slightly:
  </p>

  <pre><code data-language="javascript">{
  let x = 1;

  function test() {
    console.log('First log statement:', x);
    x = 2;
  }

  {
    x = 3;
    console.log('Second log statement:', x);
    test();
    console.log('Third log statement:', x);
  }

  console.log('Fourth log statement:', x);

  {
    console.log('Fifth log statement:', x);
    let x = 4;
    console.log('Sixth log statement:', x);
  }

  console.log('Seventh log statement:', x);
}</code></pre>

  <p>Output:</p>

  <pre><code data-language="javascript">Second log statement: 3
First log statement: 3
Third log statement: 2
Fourth log statement: 2
Fifth log statement: undefined
Sixth log statement: 4
Seventh log statement: 2</code></pre>

  <p>For extra credit, you can investigate the 'why' behind this new output.</p>

  <p>
    <i>
      If you notice any technical or grammatical errors, please feel free to
      open an issue on <a href="https://github.com/timothymalcham/personal-site/issues">
      github</a>. That would be super helpful. Thanks!
    </i>
  </p>


  <script src="../../js/rainbow.min.js"></script>

</div>
</body>
</html>